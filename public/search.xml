<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java复习-集合</title>
    <url>/2020/03/19/Java%E5%A4%8D%E4%B9%A0-Day2%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="E:\Date\MyBlog\MyBlog\public\img\img_0076.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong>集合位于java.util包中，最常见的集合是List与Map。我们先看List</strong></p>
<p>​    List中包含ArrayList、LinkedList与Vector。其中ArrayList与Vector底层是用数组实现的，LinkedList是双向链表实现的。三者的比较如下：</p>
<p>1、性能。由于数组的特性，ArrayList在访问元素时直接按照数组下标进行，时间复杂度为O(1)；但是在插入和删除时，需要移动目的插入位置之后所有的元素，因此消耗较大；双向链表的LinkedList在插入和删除时需要的时间复杂度近似为O（1），但是在访问其中某一元素时无法进行直接定位。综上，ArrayList在随机读取时具有优势，LinkedList在插入和删除时有优势。</p>
<p>2、线程安全性。 ArrayList与LinkedList都没有对方法进行同步，因此都是线程不安全的。在多个线程访问时不安全。而Vector是一个经过 线程同步后的ArrayList，因此可以保证线程安全，但是却损耗了一定的性能。</p>
<p>3、扩容。当容器中的元素越来越多时，需要对容器进行扩容。ArrayList的容量是<strong>当前容量*1.5+1</strong>，Vector默认是<strong>扩展一倍容量</strong>，而LinkedList一般不用考虑容量不够的情况。</p>
<p>4、set。set是无序，唯一的。包含HashSet,LinkedHashSet,TreeSet。HashSet的底层是哈希表i，其中的元素是无序唯一的，依赖的两个方法是<code>hashCode()</code>和<code>equals()</code>。LinkedHashSet的底层是链表和哈希表，由链表保证有序，哈希表保证唯一。TreeSet底层是红黑树。</p>
<blockquote>
<p>先调用hashcode()方法来判断哈希值是否相同，在调用equals()方法判断值是否相同。如果都为true，则证明两个元素相同。一个hashcode上可以方多个元素（同样哈希值的元素会在哈希桶中排成一列）。</p>
</blockquote>
<p>​    Map中包含HashMap,Hashtable、TreeMap。Map是键值对映射容器，key对应value。最常见的是HashMap与Hashtable。</p>
<p>1、HashMap允许键和值是null（最多允许一个键为null,多个值为null），而Hash table不行。</p>
<p>2、HashMap不是线程安全的，而Hash table是安全的。</p>
<blockquote>
<p><em>补充</em></p>
</blockquote>
<p>​    <strong>HashMap</strong>在Java7的实现中，使用的是数组+链表。整个HashMap在整体上是一个数组，而数组的每一个元素是一个单向链表，每一个节点为一个Entry实例，包含key,value,hash和next属性。Java8之后引入了红黑树，因为在之前，我们可以通过哈希值很快得定位数组下标，但是在链表中的查找的时间复杂度为O(n)，为了提高效率，将链表元素超过8 的链表转化为红黑树，在这上面寻找的时候时间复杂度可降至O(logN)。</p>
<p>​    <strong>ConcurrentHashMap</strong>与HashMap是基本一样的，但是却具有了线程安全的特性，具体的实现是将HashMap的数组分割成若干个segment，segment通过继承ReentrantLock来进行加锁，保证了每个segment的安全性，也就保证了整个的安全性。segment的内部是一个小的HashMap。Java8之后同样加入了红黑树。</p>
<p>常用的集合的实现会单独写一篇文章。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>网络复习1</title>
    <url>/2020/03/16/%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/</url>
    <content><![CDATA[<h1 id="TCP-IP协议体系结构"><a href="#TCP-IP协议体系结构" class="headerlink" title="TCP/IP协议体系结构"></a>TCP/IP协议体系结构</h1><table>
<thead>
<tr>
<th align="center">应用层：SMTP、HTTP、FTP</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>传输层：TCP、UDP</strong></td>
</tr>
<tr>
<td align="center"><strong>互连网络层：IP</strong></td>
</tr>
<tr>
<td align="center"><strong>网络接入层：物理网络</strong></td>
</tr>
</tbody></table>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><em>在建立TCP连接时，需要进行三次握手。假设现在主机A要与主机B进行连接发送数据</em></p>
<blockquote>
<p>第一次：主机A发送位码syn=1，随机产生req=x到主机B，主机B由syn=1知道A想要与自己建立连接。</p>
<p>第二次：    主机B收到请求后，向A发送<strong>ack number=x+1(主机A 的seq+1)</strong>，<strong>ACK＝１</strong>，<strong>随机产生seq=y</strong>。</p>
<p>第三次：A收到B的信息之后检查ack number是否正确，以及ACK是否为1，若都正确，主机A回复<strong>ack number=y+1(主机B的seq+1)</strong>，<strong>ACK=1</strong>,<strong>seq=x+1</strong>。主机B接收到之后检查ACK与ack number，若都正确，连接建立。</p>
</blockquote>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><em>TCP连接要释放时，需要进行四次挥手</em></p>
<blockquote>
<p>主机A已经完成了信息的发送，现在要断开TCP连接。</p>
<p>第一次：主机A发送终止标识位FIN与序列号seq=u，表明自己要与B断开连接，发送后进入终止等待态1；</p>
<p>第二次：服务器收到A的信息，回复ACK=1，确认号ack=u+1,seq=v；同时将FIN信息传达给应用进程，等待应用进程回应，A接收到后进入终止等待态2；</p>
<p>第三次：应用进程使服务器<strong>被动关闭</strong>，向主机A发送FIN信号，ACK=1，seq=w, ack=u+1,等待主机A的最后确认。</p>
<p>第四次：A接收到后向服务器发送ACK=1，seq=u+1, ack=w+1,B 收到后关闭，同时A在等待2MSL时候也关闭。连接释放。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java复习-Day1</title>
    <url>/2020/03/15/Java%E5%A4%8D%E4%B9%A0-Day1/</url>
    <content><![CDATA[<h1 id="String、StringBuffer、StringBuilder有什么区别？"><a href="#String、StringBuffer、StringBuilder有什么区别？" class="headerlink" title="String、StringBuffer、StringBuilder有什么区别？"></a>String、StringBuffer、StringBuilder有什么区别？</h1><p><strong>1、String类中使用final关键字修饰，即</strong><code>private final char value[]</code> ,<strong>所以String对象是不可变的。而Stringbuffer与StringBuilder没有被 final修饰，所以这两个对象的内容是可变的。</strong></p>
<p><strong>2、String对象是常量，线程安全；而StringBuffer对方法加了同步锁，是线程安全的；而StringBuilder并没有加锁，所以是非线程安全的。</strong></p>
<p><strong>3、由于String的不可变性，每次对一个String对象进行修改时，都会生成一个新的String对象，然后将指针指向这个新的对象，这会导致资源的浪费；而StringBuffer与StringBuilder是可变的，所以只会在当前的String对象上更改。后者比前者在性能上有10%-15%的提升但是却冒着线程不安全的风险</strong></p>
<p><strong>4、综上，在操作少量数据的时候使用String，单线程操作字符缓冲区下的大量数据使用StringBuilder,多线程下使用StringBuffer</strong></p>
<h1 id="与eauals"><a href="#与eauals" class="headerlink" title="==与eauals()"></a><code>==</code>与<code>eauals()</code></h1><p><strong><code>==</code>的作用是判断两个对象的地址是不是相等，当被判断的两个是基本数据类型时，它的作用是判断两者的值是不是相等</strong></p>
<p><strong><code>equals()</code>的作用是判断两个对象是否相等。当类没有覆盖这个方法时，它等价于<code>==</code>，当覆盖时，用于比较两者的内容是否一致。String类中就重写了这个方法。</strong></p>
<p><strong>例如：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String a=<span class="keyword">new</span> String(<span class="string">"a"</span>);<span class="comment">//新建两个对象，内容相同</span></span><br><span class="line">        String b=<span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">        String c=<span class="string">"ab"</span>;<span class="comment">//存放在常量池中</span></span><br><span class="line">        String d=<span class="string">"ab"</span>;<span class="comment">//在常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span>(a==b)&#123;	  <span class="comment">//false，两个对象的地址不同</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c==d)&#123;	  <span class="comment">//true,引用相同</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.equals(b))&#123; <span class="comment">//true,值相同</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关于final关键字的用法"><a href="#关于final关键字的用法" class="headerlink" title="关于final关键字的用法"></a>关于final关键字的用法</h1><p><strong>1、当修饰基本数据类型的变量时，数值一旦初始化之后不能更改；如果修饰引用类型的变量，则该变量不能再被另一个对象引用。</strong></p>
<p><strong>2、当修饰一个类时，该类不能被继承，类中所有的方法将会被指定为final方法</strong></p>
<p><strong>3、使用final的原因：把方法锁定，防止其含义被修改；第二个 原因是效率，但是现在的Java版本不需要这种优化了。</strong></p>
<h1 id="获取键盘输入的两种方式"><a href="#获取键盘输入的两种方式" class="headerlink" title="获取键盘输入的两种方式"></a>获取键盘输入的两种方式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Scanner</span></span><br><span class="line">Scanner input=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s=in.nextLine();</span><br><span class="line">input.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用BufferedReader</span></span><br><span class="line">BufferedReader input1 = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String x=input1.nextLine();</span><br></pre></td></tr></table></figure>

<h1 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h1><p><strong>1、接口的方法默认是public 并且不能有实现，抽象类可以有非抽象方法。</strong></p>
<p><strong>2、接口中的变量默认是final修饰，一个类可以有多个接口，但是只能有一个抽象类，并且接口的实现类必须要实现接口中所有的方法</strong></p>
<p><strong>3、接口是对行为的抽象，抽象类是一种模板设计</strong></p>
<h1 id="ArrayList与LinkedList的异同"><a href="#ArrayList与LinkedList的异同" class="headerlink" title="ArrayList与LinkedList的异同"></a>ArrayList与LinkedList的异同</h1><p><strong>两者都是Java中比较常用的容器，都是不同步的，都不能保证线程安全。ArrayList底层为object数组，LinkedList底层为双向链表（jdk1.6之前为循环链表，1.7之后取消了循环）。</strong></p>
<p><strong>ArrayList插入时，默认将数据插入到末尾，时间复杂度为O(1),要在指定位置删除或插入时，复杂度为O(n-1) 。LinkedList在插入和删除时，都要从末尾，时间复杂度近似为O(1)。</strong></p>
<p><strong>ArrayList支持随机访问，LinkedList不支持。ArrayList的空间浪费体现在数组的末尾会留有一定的空闲，LinkedList体现在每个节点需要的空间要更大（保存数据和前后节点）</strong></p>
<h2 id="ArrayList与Vector"><a href="#ArrayList与Vector" class="headerlink" title="ArrayList与Vector"></a>ArrayList与Vector</h2><p><strong>Vector的方法是同步的，可以让多个线程安全地访问，但是一个线程访问时会耗费大量的时间在同步操作上。</strong></p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
</search>
