<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode每日一题-乘积最大子数组</title>
    <url>/2020/05/18/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>leetcode每日一题-课程表</title>
    <url>/2020/05/17/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>题目描述：</p>
<p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
</blockquote>
<p>首先我们需要了解一下拓扑排序。</p>
<p>拓扑排序是针对某一类图的。这类图有两个特点：</p>
<p>1、具有方向</p>
<p>2、不含有环</p>
<p>举个很简单的例子：本科生的课程安排便是一种这样的图。理想情况下，有些课程需要一些先修课，比如在学习算法与数据结构之前需要先修C语言。当然有些课程是没有先修课的，例如数学和英语等基础课。把每一门课作为节点，课程之前的先修关系作为边，这样就构成了一个符合上面两个条件的图（有向无环图）。</p>
<p>我们还需要知道另外两个概念：出度和入度。假如算法与数据结构的先修课有C语言和离散数学，那么我们便定义算法的入度为２.相应地,因为数学没有先修课,所以入度为0.</p>
<p>了解了这些以后,我们可以进行拓扑排序了.我们将所有入度为0的节点拿出,简单理解为这门课你学完了,那么它的下一门课的入度便减一.假如下一个节点的入度减一之后变成了0,那么便再将这门课加入队列.这样循环的同时我们将队列中的节点取出,得到的便是这个图的拓扑排序.这样的意义是什么呢?我们可以简单地理解为让所有的活动都正常有序的进行(我们不可能在不会站的时候就想跑吧).</p>
<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下:"></a>代码如下:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">//答案数组</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="comment">//入度表</span></span><br><span class="line">        <span class="keyword">int</span> indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//统计入度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] q:prerequisites)&#123;</span><br><span class="line">            indegree[q[<span class="number">0</span>]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先进先出,保证顺序</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将入度为0的节点加入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//取出队头的节点</span></span><br><span class="line">            <span class="keyword">int</span> curr = queue.poll();</span><br><span class="line">            res[i++] = curr;</span><br><span class="line">            <span class="comment">//如果队头节点是某节点的先修,则将该节点的入度减一</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> []pre:prerequisites)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr == pre[<span class="number">1</span>])&#123;</span><br><span class="line">                    indegree[pre[<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="comment">//假如减一后入度为0,则加入队列</span></span><br><span class="line">                    <span class="keyword">if</span>(indegree[pre[<span class="number">0</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.offer(pre[<span class="number">0</span>])</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == numCourses?res:<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





























]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题-二叉树层序遍历</title>
    <url>/2020/05/13/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<blockquote>
<p>题目介绍</p>
<p>二叉树的层序遍历：</p>
<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
</blockquote>
<p><strong>一、思路</strong></p>
<p>使用广度优先算法，将二叉树逐层加入到答案的<code>List</code>中。</p>
<p>首先需要一个辅助队列，将根节点先加入到辅助队列中，在辅助队列不为空的情况下，先将其中的节点取出，并将取出的节点值保存到答案中，然后再将该节点的子节点加入队列。重复这个过程，就能得到答案。</p>
<p><strong>二、代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="comment">//假如根节点为空，返回</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根节点加入队列</span></span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(q.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = q.size();</span><br><span class="line">            <span class="comment">//每层的节点值</span></span><br><span class="line">            ArrayList&lt;Integer&gt; floor = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t;i++)&#123;</span><br><span class="line">                TreeNode tn = q.remove();</span><br><span class="line">                floor.add(tn.val);</span><br><span class="line">                <span class="keyword">if</span>(tn.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.add(tn.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tn.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.add(tn.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(floor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode每日一题-最大正方形</title>
    <url>/2020/05/08/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p>示例:</p>
<p>输入: </p>
<p>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p>
<p>输出: 4</p>
<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>遍历矩阵，每当找到一个为1的位置，便令这个位置作为正方形的左上角的顶点，此时要注意正方形的边长不能超越剩余的行数和列数。在这个基础上新增行和列，同时判断新增的行和列中是否含有0。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][]  matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; columns;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    maxSize = Math.max(maxSize,<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//当前可能的最大边长</span></span><br><span class="line">                    <span class="keyword">int</span> currentMaxSize = Math.min(rows-i,columns-j);</span><br><span class="line">                    <span class="comment">//先判断正方形可能的右下角顶点</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k &lt; currentMaxSize;k++)&#123;</span><br><span class="line">                        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(matrix[i+k][j+k] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果正方形右下角不为0</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>;m &lt; k;m++)&#123;</span><br><span class="line">                            <span class="comment">//判断其他位置是否为0</span></span><br><span class="line">                            <span class="keyword">if</span>(matrix[i+m][j+k] == <span class="string">'0'</span> || matrix[i+k][j+m] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                                flag = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                            maxSize = Math.max(maxSize,k+<span class="number">1</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSize*maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>review</title>
    <url>/2020/03/29/review/</url>
    <content><![CDATA[<h2 id="int与integer的区别？"><a href="#int与integer的区别？" class="headerlink" title="int与integer的区别？"></a>int与integer的区别？</h2><p>1、存储位置</p>
<p>int 存储在栈中，值在常量池中；</p>
<p>integer对象的引用存储在栈中，值存储在堆空间。</p>
<p>2、初始值</p>
<p>int初始值为0，</p>
<p>integer初始值为null</p>
<h2 id="进程与线程的区别和联系"><a href="#进程与线程的区别和联系" class="headerlink" title="进程与线程的区别和联系"></a>进程与线程的区别和联系</h2><p>1、定义：进程是并发执行的程序在执行过程中分配和资源调度的基本单位；</p>
<p>线程是进程的一个执行单元，是资源分配的基本单位。</p>
<p>一个进程由多个线程组成，而一个程序由一个或多个进程组成。</p>
<p>2、地址空间</p>
<p>进程之间的地址空间是独立的，而不同的线程共享本进程的地址。</p>
<p>3、资源占用</p>
<p>不同的进程之间的资源是相互独立的，而进程内的线程共享进程内的资源</p>
<p>4、稳定性</p>
<p>一个进程崩溃后，由于保护模式不会对其他进程造成影响，但是一个线程崩溃后将会影响到同进程内所有的线程。</p>
<p>5、进程切换需要很大的时间开销，而线程切换时间较短</p>
<h2 id="Java-GC线程"><a href="#Java-GC线程" class="headerlink" title="Java GC线程"></a>Java GC线程</h2><p>１、为什么需要GC</p>
<p>程序对资源的使用，一般包括以下步骤</p>
<p>（1）、给对应的资源分配内存</p>
<p>（2）、初始化内存</p>
<p>（3）、使用资源</p>
<p>（4）、清理资源</p>
<p>（5）、释放内存</p>
<p>C、C++需要手动管理资源，这样就存在许多问题，Java采用的是自动控制。</p>
<p>2、GC是如何工作的</p>
<p>GC工作的大体流程是</p>
<p>（1）、标记</p>
<p>（2）、计划</p>
<p>（3）、清理</p>
<p>（4）、引用更新</p>
<p>（5）、压缩</p>
<p>GC之前首先了解以下什么是GC root。每个应用程序都包含一组根，每个根是一个存储位置，其中包含着指向引用类型的一个指针。应用程序中，只要对象变得不可达，也就是没有root引用该对象，这个对象就会成为垃圾回收器的目标。</p>
<p>3、什么时候发生GC</p>
<p>1、当应用程序分配新的对象，GC代的预算已经达到阈值的时候，例如第0代已满</p>
<p>2、显式调用等情况</p>
<h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>在程序运行的过程中，所有的对象存储在运行区域的堆中，当一个对象不在被引用时，他就需要被回收，以节约资源。常见的GC算法为：</p>
<p>1、引用计数法</p>
<p>给每个对象一个引用计数器，当这个对象每被引用一次，计数器加1，当计数器为0时，证明该对象需要被清理</p>
<p>2、标记-清除算法</p>
<p>标记就是把所有活动的对象都做上标记，清除就是将没有被标记的对象进行回收。缺点是会引起内存的碎片化。</p>
<p>3、复制算法</p>
<p>整理算法是把内存分为大小相等的两部分，每次使用其中的一块，当一块快用完时，对该块的存活对象复制到另一块中，再把使用过的块进行清理。这个算法的优点是解决了碎片的问题，但是开销特别大，需要将内存区域减半，内存利用率降低。</p>
<p>4、标记-整理算法</p>
<p>标记-整理算法与标记-清除算法基本一致，但后续步骤不是将可直接回收的对象一一清理，而是让存活对象向一端移动，然后直接清理边界以外的内存。</p>
<p>5、分代收集算法</p>
<p>分代收集算法是对上述算法的整合。大体的思想是将Java的堆分为老年代和新生代，在新生代中，每次垃圾收集都会有许多的对象死去，存活对象很少，因此可以使用复制算法；在老年代中，对象的死亡率低，因此可以使用标记-清除算法或者标记-整理算法。</p>
<h2 id="为什么要进行三次握手和四次挥手"><a href="#为什么要进行三次握手和四次挥手" class="headerlink" title="为什么要进行三次握手和四次挥手"></a>为什么要进行三次握手和四次挥手</h2><p>1、三次握手</p>
<p><strong>为了防止已经失效的连接请求报文段突然又被传到了服务端导致的资源浪费</strong></p>
<p>举例：假如客户端成功发出的请求连接报文在中途出现了较长时间的滞留，但是一段时间后仍然到达服务器，服务器就会把它当作一个新的请求连接报文，于是服务器返回同意建立连接的报文，假设没有三次握手，那么此次连接建立，但是客户端并没有要发送的数据，因此白白浪费了资源。</p>
<p>2、四次挥手</p>
<p><strong>为了彻底关闭TCP连接</strong></p>
<p>因为tcp连接是全双工的，客户端发送FIN报文时证明自己已经没有数据要发送了，服务器回复ACK证明同意客户端断开连接；但是这时服务器仍然可以向客户端发送数据，所以需要服务器也回复FIN报文，证明服务器也没有数据要回复了，客户端恢复后才彻底关闭连接。</p>
<h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><p>1、主从式</p>
<p>主进程-从进程。</p>
<p>主进程可以自由地使用从进程的数据，从进程的动作收到主进程的控制。</p>
<p>2、会话式</p>
<p>使用进程-服务进程</p>
<p>使用进程调用服务进程提供的服务，使用进程在使用服务进程提供的服务之前要获得服务进程的许可，服务进程根据使用进程的需要提供服务，但是服务的控制权仍由服务进程掌握。使用进程与服务进程在使用上有固定连接关系。</p>
<p>3、消息队列或邮箱</p>
<p>消息用于表示所交换的数据，传递大量信息之外，还意味着两个互相通信的进程地位平等。缓冲区或邮箱专门存放被传递的消息。只要缓冲区或邮箱存在空闲，无论接收进程是否准备好接收数据，发送进程都会将消息送入缓冲区队列或邮箱。发送进程和接收进程之间没有直接连接的关系。</p>
<p>4、共享存储区</p>
<p>读进程-写进程</p>
<p>两个相互需要交换信息的进程通过对同一共享数据区的操作来达到相互通信的目的。不要求数据移动。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>1、什么是死锁</p>
<p>系统中两个或多个进程无限期地等待永远不可能发生地条件，系统处于停滞状态，这种现象称为进程死锁。</p>
<p>2、死锁产生的条件</p>
<p>（1）、互斥使用（资源独占）一个资源一次只能给一个进程使用。</p>
<p>（2）、不可强占（不可剥夺）资源申请者不能从资源占有者的手中夺取资源，只能等待占有者主动释放</p>
<p>（3）、请求和保持  一个进程在申请新的资源的同时保持对原有资源的占有。</p>
<p>（4）、循环等待  形成一个进程等待环路。</p>
<p>3、死锁的预防</p>
<p>（1）、破坏不可剥夺这一条件。一个进程在申请的所有资源不能立即得到满足时，必须释放已经持有的所有资源。</p>
<p>（2）、破坏 请求和保持 这一条件。要求每个进程在运行前必须一次申请所有的资源，当且仅当所有资源都可以满足时才给予一次性分配。</p>
<p>（3）、破坏  循环等待  条件   采用资源有序分配法，把系统中所有的资源进行编号，进程在申请资源时必须严格按照编号递增的顺序。</p>
<p>3、死锁的避免</p>
<p>银行家算法</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>1、OSI/RM（仅仅是理论的层次结构）</p>
<table>
<thead>
<tr>
<th align="left"><strong>应用层</strong>：包含应用的各种协议，例如HTTP，TFTP，Telnet，SNMP，DNS</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>表示层：数据格式变换，数据加密解密，数据压缩和恢复</strong></td>
</tr>
<tr>
<td align="left"><strong>会话层：负责维护通信中两个通信节点的会话的连接和断开</strong></td>
</tr>
<tr>
<td align="left"><strong>传输层：提供端到端的数据传输服务，为上层屏蔽底层数据传输问题</strong></td>
</tr>
<tr>
<td align="left"><strong>网络层：为分组交换网络上的不同主机提供通信服务，选择合适的路由以及实现拥塞控制</strong></td>
</tr>
<tr>
<td align="left"><strong>数据链路层：在通信的实体间建立起数据链路连接，并采取差错控制和流量控制</strong></td>
</tr>
<tr>
<td align="left"><strong>物理层：物理连接，实现透明的比特流传输</strong></td>
</tr>
</tbody></table>
<p>2、TCP/IP</p>
<table>
<thead>
<tr>
<th align="center">应用层</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>传输层</strong></td>
</tr>
<tr>
<td align="center"><strong>互联网络层</strong></td>
</tr>
<tr>
<td align="center"><strong>网络接入层</strong></td>
</tr>
</tbody></table>
<p><strong>应用层</strong>的协议包括HTTP(超文本传输协议)、SMTP（电子邮件协议）、TFTP(简单文件传输协议)、Telnet（远程登录协议）、SNMP（简单网络管理协议）、DNS（域名系统）</p>
<p><strong>传输层</strong>的协议包括大名鼎鼎的<strong>TCP协议和UDP协议。</strong></p>
<p><strong>互连网络层</strong>的协议就是传说中的<strong>IP协议</strong></p>
<p><em>可以看到，虽然该协议称为TCP／IP协议，但实际上是ＴＣＰ／ＩＰ的协议簇，只是因为这两个的地位比较重要。</em></p>
<h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a><strong>TCP与UDP的区别</strong></h2><p>１、TCP是面向连接，可靠的数据流传输，而UDP是非面向连接的，不可靠的数据流传输。TCP注重数据的安全性，UDP传输的速率快。</p>
]]></content>
  </entry>
  <entry>
    <title>Java复习-集合</title>
    <url>/2020/03/19/Java%E5%A4%8D%E4%B9%A0-Day2%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="E:\Date\MyBlog\MyBlog\public\img\img_0076.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong>集合位于java.util包中，最常见的集合是List与Map。我们先看List</strong></p>
<p>​    List中包含ArrayList、LinkedList与Vector。其中ArrayList与Vector底层是用数组实现的，LinkedList是双向链表实现的。三者的比较如下：</p>
<p>1、性能。由于数组的特性，ArrayList在访问元素时直接按照数组下标进行，时间复杂度为O(1)；但是在插入和删除时，需要移动目的插入位置之后所有的元素，因此消耗较大；双向链表的LinkedList在插入和删除时需要的时间复杂度近似为O（1），但是在访问其中某一元素时无法进行直接定位。综上，ArrayList在随机读取时具有优势，LinkedList在插入和删除时有优势。</p>
<p>2、线程安全性。 ArrayList与LinkedList都没有对方法进行同步，因此都是线程不安全的。在多个线程访问时不安全。而Vector是一个经过 线程同步后的ArrayList，因此可以保证线程安全，但是却损耗了一定的性能。</p>
<p>3、扩容。当容器中的元素越来越多时，需要对容器进行扩容。ArrayList的容量是<strong>当前容量*1.5+1</strong>，Vector默认是<strong>扩展一倍容量</strong>，而LinkedList一般不用考虑容量不够的情况。</p>
<p>4、set。set是无序，唯一的。包含HashSet,LinkedHashSet,TreeSet。HashSet的底层是哈希表i，其中的元素是无序唯一的，依赖的两个方法是<code>hashCode()</code>和<code>equals()</code>。LinkedHashSet的底层是链表和哈希表，由链表保证有序，哈希表保证唯一。TreeSet底层是红黑树。</p>
<blockquote>
<p>先调用hashcode()方法来判断哈希值是否相同，在调用equals()方法判断值是否相同。如果都为true，则证明两个元素相同。一个hashcode上可以方多个元素（同样哈希值的元素会在哈希桶中排成一列）。</p>
</blockquote>
<p>​    Map中包含HashMap,Hashtable、TreeMap。Map是键值对映射容器，key对应value。最常见的是HashMap与Hashtable。</p>
<p>1、HashMap允许键和值是null（最多允许一个键为null,多个值为null），而Hash table不行。</p>
<p>2、HashMap不是线程安全的，而Hash table是安全的。</p>
<blockquote>
<p><em>补充</em></p>
</blockquote>
<p>​    <strong>HashMap</strong>在Java7的实现中，使用的是数组+链表。整个HashMap在整体上是一个数组，而数组的每一个元素是一个单向链表，每一个节点为一个Entry实例，包含key,value,hash和next属性。Java8之后引入了红黑树，因为在之前，我们可以通过哈希值很快得定位数组下标，但是在链表中的查找的时间复杂度为O(n)，为了提高效率，将链表元素超过8 的链表转化为红黑树，在这上面寻找的时候时间复杂度可降至O(logN)。</p>
<p>​    <strong>ConcurrentHashMap</strong>与HashMap是基本一样的，但是却具有了线程安全的特性，具体的实现是将HashMap的数组分割成若干个segment，segment通过继承ReentrantLock来进行加锁，保证了每个segment的安全性，也就保证了整个的安全性。segment的内部是一个小的HashMap。Java8之后同样加入了红黑树。</p>
<p>常用的集合的实现会单独写一篇文章。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>网络复习1</title>
    <url>/2020/03/16/%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A01/</url>
    <content><![CDATA[<h1 id="TCP-IP协议体系结构"><a href="#TCP-IP协议体系结构" class="headerlink" title="TCP/IP协议体系结构"></a>TCP/IP协议体系结构</h1><table>
<thead>
<tr>
<th align="center">应用层：SMTP、HTTP、FTP</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>传输层：TCP、UDP</strong></td>
</tr>
<tr>
<td align="center"><strong>互连网络层：IP</strong></td>
</tr>
<tr>
<td align="center"><strong>网络接入层：物理网络</strong></td>
</tr>
</tbody></table>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><em>在建立TCP连接时，需要进行三次握手。假设现在主机A要与主机B进行连接发送数据</em></p>
<blockquote>
<p>第一次：主机A发送位码syn=1，随机产生req=x到主机B，主机B由syn=1知道A想要与自己建立连接。</p>
<p>第二次：    主机B收到请求后，向A发送<strong>ack number=x+1(主机A 的seq+1)</strong>，<strong>ACK＝１</strong>，<strong>随机产生seq=y</strong>。</p>
<p>第三次：A收到B的信息之后检查ack number是否正确，以及ACK是否为1，若都正确，主机A回复<strong>ack number=y+1(主机B的seq+1)</strong>，<strong>ACK=1</strong>,<strong>seq=x+1</strong>。主机B接收到之后检查ACK与ack number，若都正确，连接建立。</p>
</blockquote>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><em>TCP连接要释放时，需要进行四次挥手</em></p>
<blockquote>
<p>主机A已经完成了信息的发送，现在要断开TCP连接。</p>
<p>第一次：主机A发送终止标识位FIN与序列号seq=u，表明自己要与B断开连接，发送后进入终止等待态1；</p>
<p>第二次：服务器收到A的信息，回复ACK=1，确认号ack=u+1,seq=v；同时将FIN信息传达给应用进程，等待应用进程回应，A接收到后进入终止等待态2；</p>
<p>第三次：应用进程使服务器<strong>被动关闭</strong>，向主机A发送FIN信号，ACK=1，seq=w, ack=u+1,等待主机A的最后确认。</p>
<p>第四次：A接收到后向服务器发送ACK=1，seq=u+1, ack=w+1,B 收到后关闭，同时A在等待2MSL时候也关闭。连接释放。</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java复习-Day1</title>
    <url>/2020/03/15/Java%E5%A4%8D%E4%B9%A0-Day1/</url>
    <content><![CDATA[<h1 id="String、StringBuffer、StringBuilder有什么区别？"><a href="#String、StringBuffer、StringBuilder有什么区别？" class="headerlink" title="String、StringBuffer、StringBuilder有什么区别？"></a>String、StringBuffer、StringBuilder有什么区别？</h1><p><strong>1、String类中使用final关键字修饰，即</strong><code>private final char value[]</code> ,<strong>所以String对象是不可变的。而Stringbuffer与StringBuilder没有被 final修饰，所以这两个对象的内容是可变的。</strong></p>
<p><strong>2、String对象是常量，线程安全；而StringBuffer对方法加了同步锁，是线程安全的；而StringBuilder并没有加锁，所以是非线程安全的。</strong></p>
<p><strong>3、由于String的不可变性，每次对一个String对象进行修改时，都会生成一个新的String对象，然后将指针指向这个新的对象，这会导致资源的浪费；而StringBuffer与StringBuilder是可变的，所以只会在当前的String对象上更改。后者比前者在性能上有10%-15%的提升但是却冒着线程不安全的风险</strong></p>
<p><strong>4、综上，在操作少量数据的时候使用String，单线程操作字符缓冲区下的大量数据使用StringBuilder,多线程下使用StringBuffer</strong></p>
<h1 id="与eauals"><a href="#与eauals" class="headerlink" title="==与eauals()"></a><code>==</code>与<code>eauals()</code></h1><p><strong><code>==</code>的作用是判断两个对象的地址是不是相等，当被判断的两个是基本数据类型时，它的作用是判断两者的值是不是相等</strong></p>
<p><strong><code>equals()</code>的作用是判断两个对象是否相等。当类没有覆盖这个方法时，它等价于<code>==</code>，当覆盖时，用于比较两者的内容是否一致。String类中就重写了这个方法。</strong></p>
<p><strong>例如：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String a=<span class="keyword">new</span> String(<span class="string">"a"</span>);<span class="comment">//新建两个对象，内容相同</span></span><br><span class="line">        String b=<span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">        String c=<span class="string">"ab"</span>;<span class="comment">//存放在常量池中</span></span><br><span class="line">        String d=<span class="string">"ab"</span>;<span class="comment">//在常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span>(a==b)&#123;	  <span class="comment">//false，两个对象的地址不同</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c==d)&#123;	  <span class="comment">//true,引用相同</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.equals(b))&#123; <span class="comment">//true,值相同</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关于final关键字的用法"><a href="#关于final关键字的用法" class="headerlink" title="关于final关键字的用法"></a>关于final关键字的用法</h1><p><strong>1、当修饰基本数据类型的变量时，数值一旦初始化之后不能更改；如果修饰引用类型的变量，则该变量不能再被另一个对象引用。</strong></p>
<p><strong>2、当修饰一个类时，该类不能被继承，类中所有的方法将会被指定为final方法</strong></p>
<p><strong>3、使用final的原因：把方法锁定，防止其含义被修改；第二个 原因是效率，但是现在的Java版本不需要这种优化了。</strong></p>
<h1 id="获取键盘输入的两种方式"><a href="#获取键盘输入的两种方式" class="headerlink" title="获取键盘输入的两种方式"></a>获取键盘输入的两种方式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Scanner</span></span><br><span class="line">Scanner input=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s=in.nextLine();</span><br><span class="line">input.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用BufferedReader</span></span><br><span class="line">BufferedReader input1 = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String x=input1.nextLine();</span><br></pre></td></tr></table></figure>

<h1 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h1><p><strong>1、接口的方法默认是public 并且不能有实现，抽象类可以有非抽象方法。</strong></p>
<p><strong>2、接口中的变量默认是final修饰，一个类可以有多个接口，但是只能有一个抽象类，并且接口的实现类必须要实现接口中所有的方法</strong></p>
<p><strong>3、接口是对行为的抽象，抽象类是一种模板设计</strong></p>
<h1 id="ArrayList与LinkedList的异同"><a href="#ArrayList与LinkedList的异同" class="headerlink" title="ArrayList与LinkedList的异同"></a>ArrayList与LinkedList的异同</h1><p><strong>两者都是Java中比较常用的容器，都是不同步的，都不能保证线程安全。ArrayList底层为object数组，LinkedList底层为双向链表（jdk1.6之前为循环链表，1.7之后取消了循环）。</strong></p>
<p><strong>ArrayList插入时，默认将数据插入到末尾，时间复杂度为O(1),要在指定位置删除或插入时，复杂度为O(n-1) 。LinkedList在插入和删除时，都要从末尾，时间复杂度近似为O(1)。</strong></p>
<p><strong>ArrayList支持随机访问，LinkedList不支持。ArrayList的空间浪费体现在数组的末尾会留有一定的空闲，LinkedList体现在每个节点需要的空间要更大（保存数据和前后节点）</strong></p>
<h2 id="ArrayList与Vector"><a href="#ArrayList与Vector" class="headerlink" title="ArrayList与Vector"></a>ArrayList与Vector</h2><p><strong>Vector的方法是同步的，可以让多个线程安全地访问，但是一个线程访问时会耗费大量的时间在同步操作上。</strong></p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
  </entry>
</search>
